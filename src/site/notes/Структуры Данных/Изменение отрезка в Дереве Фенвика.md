---
{"dg-publish":true,"permalink":"/struktury-dannyh/izmenenie-otrezka-v-dereve-fenvika/"}
---

[[Структуры Данных/Дерево Фенвика\|Дерево Фенвика]] — красивая структура, которую довольно быстро можно закодить.  Однако проосирает [Дереву Отрезков](дерево отрезков), ведь не может в изменения на интервале.

Ща я решу эту проблему

Решаем проблему на $a$

Идея в том, чтобы приставить что существует какой-то $b$ - просто какой-то массив.  А наш массив $a$ — это его [[Структуры Данных/Префиксная сумма\|префиксная сумма]].

Т.е.
$$a_i = b_1 + b_2 + \cdots + b_i$$
Здесь надо чуть подумать.  

*Как изменить интервал от $l$ до конца ($n$)?*

Надо изменить $b_i$!  Ведь так, как $a$ это префиксная сумма, то все префксные суммы после $a_i$ будут иметь $b_i$, меняя $b_i$ мы меняем целый интервал.

Получается можно к $a_i$ прибавить $x$, и тогда мы изменим интервал $[i; n]$.  Чтобы изменить интервал $[i; j]$, надо сделать 2 запроса: $[i; n] + x$, $[j+1; n] - x$

А чтобы получить значение $a$ в $i$, надо просто запустить `sum(i)`

Получается, используя ту же [[Структуры Данных/Запросная Структура\|Запросная Структура]], делать и обновление

## UPD Новое объяснение
Рассмотрю ещё раз условие: приходят запросы (1) прибавить к элементам массива с индексами от $l$ до $r$ число $x$ (2) узнать значение массива под индексом $i$

Для начала заявлю, что нужен массив вспомогательный $b$ с помощью его можно будет узнать на сколько увеличилось $a_i$, т.е. Я формулирую задачу не *"нужно найти $a_i$ после запросов"*, а вместо этого *"нужно найти на сколько увеличилось $a_i$"*, зная измененение $a_i$ и оригинальный $a_i$, можно легко узнать нужный аи после запросов (загуглите плюс)

Ответить на этот вопрос легко $a_i$ увеличилось на сумму $b$ от 0 до $i$ (включительно) (назову это $f(i)$).  

Тогда, чтобы увеличить все элементы от $l$ до $n$, нужно увеличить на один $b_l$ и вправду все $f(i)$ станут больше.

А чтобы делать запросы не только на $[l; n]$, но и на $[l; r]$ необходимо после, увеличение $[l; n]$ на $x$, уменьшить $[r+1; n]$ на $x$  , чтобы отменить эффект

Так как сумму и изменение можно делать за $O(\log N)$, то сложность такая.  Просто псевдоеода немного на последок:

```
add(l, r, x): # add +x on [l; r)
  add(l, x)
  add(r, -x)

get(i)
  sum(i)
```